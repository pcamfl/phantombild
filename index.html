<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Das Phantombild: Deluxe Edition</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --card-bg: #ecf0f1;
            --accent: #e67e22; /* Carrot orange */
            --success: #2ecc71;
            --error: #e74c3c;
            --text: #34495e;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            overflow-x: hidden;
            user-select: none;
        }

        /* --- HUD (Heads Up Display) --- */
        .hud {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .stat-box {
            text-align: center;
        }

        .stat-label { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; opacity: 0.8; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: var(--accent); }

        /* Timer Bar */
        .timer-container {
            width: 100%;
            max-width: 800px;
            height: 10px;
            background: #34495e;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .timer-bar {
            height: 100%;
            background: var(--success);
            width: 100%;
            transition: width 0.1s linear, background-color 0.5s;
        }

        .timer-bar.critical { background: var(--error); }

        /* --- WANTED POSTER --- */
        .wanted-poster {
            background: #fffbe6; /* Paper color */
            color: #2c3e50;
            padding: 20px;
            width: 90%;
            max-width: 600px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 2px;
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transform: rotate(-1deg);
            transition: transform 0.3s;
        }

        .wanted-poster::before {
            content: "GESUCHT";
            display: block;
            font-weight: 900;
            font-size: 2rem;
            color: #c0392b;
            border: 4px solid #c0392b;
            display: inline-block;
            padding: 5px 15px;
            transform: rotate(-5deg);
            margin-bottom: 10px;
        }

        .description-text {
            font-size: 1.3rem;
            line-height: 1.4;
        }

        .highlight {
            color: #d35400;
            font-weight: bold;
        }

        /* --- LINEUP GRID --- */
        .lineup-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 800px;
        }

        .suspect-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 10px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 6px solid #bdc3c7;
            animation: popIn 0.4s ease-out backwards;
        }

        .suspect-card:active {
            transform: translateY(4px);
            border-bottom-width: 2px;
        }

        .suspect-card:hover {
            transform: translateY(-2px);
        }

        .suspect-card img {
            width: 100%;
            height: auto;
            border-radius: 50%;
            background: #fff;
        }

        /* Juice Effects */
        .suspect-card.wrong {
            background-color: #fab1a0;
            filter: grayscale(100%);
            opacity: 0.5;
            pointer-events: none;
            animation: shake 0.4s;
        }

        .suspect-card.correct {
            background-color: #55efc4;
            transform: scale(1.05);
            border-color: #00b894;
            z-index: 10;
        }

        /* Floating Text (Points/Time) */
        .floater {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 1s forwards;
            z-index: 100;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* Screens (Start/Game Over) */
        .screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            backdrop-filter: blur(5px);
        }
        
        .hidden { display: none; }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4);
            transition: transform 0.2s;
        }
        .btn:hover { transform: scale(1.1); }

        /* Animations */
        @keyframes popIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            50% { transform: translateX(10px); }
            75% { transform: translateX(-10px); }
            100% { transform: translateX(0); }
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 900;
        }

    </style>
</head>
<body>

    <!-- START SCREEN -->
    <div id="start-screen" class="screen">
        <h1 style="font-size: 3rem; margin-bottom: 0;">Das Phantombild</h1>
        <p style="font-size: 1.2rem; color: #bdc3c7;">Find the suspect before time runs out!</p>
        <button class="btn" onclick="startGame()">Start Game</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="screen hidden">
        <h1>ZEIT ABGELAUFEN!</h1>
        <div class="stat-box">
            <div class="stat-label">Final Score</div>
            <div class="stat-value" id="final-score" style="font-size: 4rem;">0</div>
        </div>
        <button class="btn" onclick="startGame()">Play Again</button>
    </div>

    <!-- MAIN GAME -->
    <div class="hud">
        <div class="stat-box">
            <div class="stat-label">Level</div>
            <div class="stat-value" id="level-display">1</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Score</div>
            <div class="stat-value" id="score-display">0</div>
        </div>
    </div>

    <div class="timer-container">
        <div class="timer-bar" id="timer-bar"></div>
    </div>

    <div class="wanted-poster" id="poster">
        <div class="description-text" id="description">
            Loading...
        </div>
    </div>

    <div class="lineup-container" id="lineup">
        <!-- Cards generated by JS -->
    </div>

    <canvas id="confetti-canvas"></canvas>

<script>
    // --- VOCABULARY DATABASE ---
    
    const hairColors = [
        { de: "blonde", api: "f59797" },
        { de: "braune", api: "4a312c" },
        { de: "schwarze", api: "000000" },
        { de: "rote", api: "b55835" },
        { de: "graue", api: "e8e8e8" }
    ];

    const roles = [
        { de: "der Bruder", pron: "Er", gender: "male" },
        { de: "die Schwester", pron: "Sie", gender: "female" },
        { de: "der Opa", pron: "Er", gender: "male" }, // Just treating as male for hair length logic
        { de: "die Oma", pron: "Sie", gender: "female" }
    ];

    const moods = [
        { de: "glücklich", mouth: "smile", eyes: "happy" },
        { de: "traurig", mouth: "sad", eyes: "normal" }, // Normal eyes + sad mouth = sad
        { de: "ernst", mouth: "serious", eyes: "normal" },
        { de: "böse", mouth: "serious", eyes: "angry" } // Angry eyes + serious mouth = angry
    ];

    const glasses = [
        { de: "eine Brille", has: true },
        { de: "keine Brille", has: false }
    ];

    // --- GAME STATE ---
    let state = {
        score: 0,
        level: 1,
        timeLeft: 60, // Total seconds
        maxTime: 60,
        target: null,
        isPlaying: false,
        timerInterval: null
    };

    // --- GENERATORS ---

    function getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function generatePerson() {
        return {
            id: Math.random().toString(36).substr(2, 9),
            hair: getRandom(hairColors),
            role: getRandom(roles),
            mood: getRandom(moods),
            glass: getRandom(glasses),
            seed: Math.random() // For DiceBear
        };
    }

    // Build API URL based on person properties
    function getAvatarUrl(person) {
        let url = `https://api.dicebear.com/9.x/avataaars/svg?seed=${person.seed}`;
        
        // Hair Color
        url += `&hairColor=${person.hair.api}`;
        
        // Gender/Hair Length (Heuristic)
        if(person.role.gender === 'female') {
            url += `&top=longHairStraight,longHairBob,longHairCurly`;
        } else {
            url += `&top=shortHairShortFlat,shortHairTheCaesar,shortHairFrizzle`;
        }

        // Mood (Mouth & Eyes)
        url += `&mouth=${person.mood.mouth}&eyes=${person.mood.eyes}`;

        // Glasses
        if(person.glass.has) {
            url += `&accessories=kurt,prescription01,prescription02&accessoriesProbability=100`;
        } else {
            url += `&accessoriesProbability=0`;
        }

        return url;
    }

    // --- GAME LOGIC ---

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        state.score = 0;
        state.level = 1;
        state.timeLeft = 60;
        state.isPlaying = true;
        
        updateHUD();
        startTimer();
        newRound();
    }

    function startTimer() {
        if(state.timerInterval) clearInterval(state.timerInterval);
        state.timerInterval = setInterval(() => {
            if(!state.isPlaying) return;
            
            state.timeLeft -= 0.1;
            
            const bar = document.getElementById('timer-bar');
            const pct = (state.timeLeft / state.maxTime) * 100;
            bar.style.width = `${pct}%`;

            if(state.timeLeft <= 10) bar.classList.add('critical');
            else bar.classList.remove('critical');

            if(state.timeLeft <= 0) gameOver();
        }, 100);
    }

    function gameOver() {
        state.isPlaying = false;
        clearInterval(state.timerInterval);
        document.getElementById('final-score').textContent = state.score;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function determineLevel() {
        // Difficulty scaling
        if(state.score < 3) return 1; // Just Hair
        if(state.score < 8) return 2; // Hair + Role
        if(state.score < 15) return 3; // Hair + Role + Glasses
        return 4; // Everything
    }

    function newRound() {
        if(!state.isPlaying) return;

        state.level = determineLevel();
        updateHUD();

        // 1. Create Target
        const target = generatePerson();
        state.target = target;

        // 2. Determine Lineup Size
        let count = 3;
        if(state.level >= 2) count = 4;
        if(state.level >= 4) count = 6;

        // 3. Generate Distractors
        // Distractors must NOT match the specific clues given in the current level
        let suspects = [target];
        
        while(suspects.length < count) {
            let d = generatePerson();
            let clash = false;

            // CHECK CLASHES (Don't create a duplicate of the correct answer)
            // Logic: A distractor is bad if it matches ALL the clues we are about to give.
            
            let matchesHair = d.hair.de === target.hair.de;
            let matchesRole = d.role.de === target.role.de;
            let matchesGlass = d.glass.de === target.glass.de;
            let matchesMood = d.mood.de === target.mood.de;

            if (state.level === 1) {
                if(matchesHair) clash = true; // Level 1 clue is only hair. Distractor can't have same hair.
            } else if (state.level === 2) {
                if(matchesHair && matchesRole) clash = true; 
            } else if (state.level === 3) {
                if(matchesHair && matchesRole && matchesGlass) clash = true;
            } else {
                if(matchesHair && matchesRole && matchesGlass && matchesMood) clash = true;
            }

            if(!clash) suspects.push(d);
        }

        // Shuffle
        suspects.sort(() => Math.random() - 0.5);

        // 4. Render
        renderScene(target, suspects);
    }

    function renderScene(target, suspects) {
        // Build Description String
        let html = "";
        const h = `<span class='highlight'>`;
        const e = `</span>`;

        if(state.level === 1) {
            html = `Gesucht wird eine Person mit ${h}${target.hair.de} Haaren${e}.`;
        } 
        else if (state.level === 2) {
            html = `Gesucht wird ${h}${target.role.de}${e}.<br>
                    ${target.role.pron} hat ${h}${target.hair.de} Haare${e}.`;
        }
        else if (state.level === 3) {
            html = `Gesucht wird ${h}${target.role.de}${e}.<br>
                    ${target.role.pron} hat ${h}${target.hair.de} Haare${e}.<br>
                    ${target.role.pron} hat ${h}${target.glass.de}${e}.`;
        }
        else {
             html = `Gesucht wird ${h}${target.role.de}${e}.<br>
                    ${target.role.pron} ist ${h}${target.mood.de}${e}.<br>
                    ${target.role.pron} hat ${h}${target.hair.de} Haare${e} und ${h}${target.glass.de}${e}.`;
        }

        document.getElementById('description').innerHTML = html;

        // Build Cards
        const container = document.getElementById('lineup');
        container.innerHTML = '';

        suspects.forEach((p, index) => {
            const card = document.createElement('div');
            card.className = 'suspect-card';
            card.style.animationDelay = `${index * 0.1}s`; // Staggered entrance
            
            const img = document.createElement('img');
            img.src = getAvatarUrl(p);
            
            card.appendChild(img);
            card.onclick = (e) => handleGuess(p.id, card, e);
            
            container.appendChild(card);
        });
    }

    function handleGuess(id, card, event) {
        if(card.classList.contains('wrong') || card.classList.contains('correct')) return;

        if(id === state.target.id) {
            // CORRECT
            card.classList.add('correct');
            state.score++;
            
            // Time Bonus
            let bonus = 3;
            if(state.level >= 3) bonus = 5;
            state.timeLeft = Math.min(state.timeLeft + bonus, state.maxTime);
            
            showFloater(event.clientX, event.clientY, `+${bonus}s`, '#2ecc71');
            fireConfetti();

            setTimeout(newRound, 1000); // Wait 1s then next round
        } else {
            // WRONG
            card.classList.add('wrong');
            state.timeLeft -= 2;
            showFloater(event.clientX, event.clientY, `-2s`, '#e74c3c');
            
            // Shake the poster
            const poster = document.getElementById('poster');
            poster.style.transform = "rotate(5deg) scale(0.95)";
            setTimeout(() => poster.style.transform = "rotate(-1deg)", 200);
        }
        updateHUD();
    }

    function updateHUD() {
        document.getElementById('score-display').textContent = state.score;
        document.getElementById('level-display').textContent = state.level;
    }

    function showFloater(x, y, text, color) {
        const el = document.createElement('div');
        el.className = 'floater';
        el.textContent = text;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    // --- CONFETTI (Simple Implementation) ---
    function fireConfetti() {
        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const pieces = [];
        for(let i=0; i<50; i++) {
            pieces.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 1) * 10,
                color: `hsl(${Math.random()*360}, 100%, 50%)`
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let alive = false;
            pieces.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // Gravity
                p.vx *= 0.95; // Air resistance
                
                if(p.y < canvas.height) {
                    alive = true;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 6, 6);
                }
            });
            if(alive) requestAnimationFrame(animate);
            else ctx.clearRect(0,0,canvas.width, canvas.height);
        }
        animate();
    }

</script>
</body>
</html>

